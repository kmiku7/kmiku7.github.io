<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kmiku7&#39;s blog</title>
  
    <meta name="robots" content="noindex, follow">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="kmiku7&#39;s blog">
<meta property="og:url" content="http://kmiku7.github.io/page/2/index.html">
<meta property="og:site_name" content="kmiku7&#39;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kmiku7&#39;s blog">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <!--link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"-->
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-27155459-3', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kmiku7&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">JUST DO IT.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kmiku7.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-basic-aho-corasick-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/25/basic-aho-corasick-algorithm/" class="article-date">
  <time datetime="2015-04-25T13:19:50.000Z" itemprop="datePublished">Apr 25 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/basic-aho-corasick-algorithm/">AC-Search实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写了一遍多字符串匹配的ac-search算法，输出所有的原串匹配区间。  </p>
<p>build_trie()构造一个trie，build_longest_trans_target()函数构造自动机无法前向匹配时的转移路径，即TrieNode::prefix字段。当自动机到达一个最终状态后(terminal state，TrieNode::pattern_end)构造原串当前位置之前的所有匹配区间，通过把patterns串reverse之后构造出一个prefix树然后遍历实现。如果有更好的匹配串构造方法请留言。  </p>
<p>原理请参考： &lt;Flexible Pattern Matching in Strings&gt;, 3.2.2 Basic Aho-Corasick Algorithm.</p>
<h4 id="Trie-amp-reverse-patterns-之后的trie树和状态机构造代码"><a href="#Trie-amp-reverse-patterns-之后的trie树和状态机构造代码" class="headerlink" title="Trie &amp; reverse(patterns)之后的trie树和状态机构造代码"></a>Trie &amp; reverse(patterns)之后的trie树和状态机构造代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">sibling</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">prefix</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height; <span class="comment">// 1, 2, 3 ...</span></span><br><span class="line">    <span class="keyword">bool</span> pattern_end;</span><br><span class="line">    <span class="keyword">char</span> this_char;</span><br><span class="line">    TrieNode() : sibling(<span class="literal">nullptr</span>), children(<span class="literal">nullptr</span>), prefix(<span class="literal">nullptr</span>), </span><br><span class="line">            height(<span class="number">0</span>), pattern_end(<span class="literal">false</span>), this_char(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieNode* <span class="title">get_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_node</span><span class="params">(TrieNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_trie</span><span class="params">(TrieNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">        root = <span class="built_in">stack</span>.back();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.back() = root-&gt;sibling;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(root-&gt;children);</span><br><span class="line">        release_node(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assumption: there are no duplicate item and no empty string in strs.</span></span><br><span class="line"><span class="function">TrieNode* <span class="title">build_trie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// build root;</span></span><br><span class="line">    TrieNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : strs) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        TrieNode** insert_pos = &amp;root;</span><br><span class="line">        TrieNode* parent_node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> curr_char : str) &#123;</span><br><span class="line">            <span class="comment">// find insert pos</span></span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(*insert_pos!=<span class="literal">nullptr</span> &amp;&amp; (*insert_pos)-&gt;this_char&lt;curr_char)</span><br><span class="line">                insert_pos = &amp;(*insert_pos)-&gt;sibling;</span><br><span class="line"></span><br><span class="line">            parent_node = *insert_pos;</span><br><span class="line">            <span class="comment">// new char, insert</span></span><br><span class="line">            <span class="keyword">if</span>(*insert_pos==<span class="literal">nullptr</span> || (*insert_pos)-&gt;this_char&gt;curr_char) &#123;</span><br><span class="line">                parent_node = get_node();</span><br><span class="line">                parent_node-&gt;sibling = *insert_pos;</span><br><span class="line">                parent_node-&gt;this_char = curr_char;</span><br><span class="line">                parent_node-&gt;height = len;</span><br><span class="line">                *insert_pos = parent_node;</span><br><span class="line">            &#125;</span><br><span class="line">            insert_pos = &amp;parent_node-&gt;children;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// no duplicate</span></span><br><span class="line">        assert(parent_node &amp;&amp; parent_node-&gt;pattern_end==<span class="literal">false</span>);</span><br><span class="line">        parent_node-&gt;pattern_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略这个名字吧。。</span></span><br><span class="line"><span class="function">TrieNode* <span class="title">build_suffix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    TrieNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : strs) &#123;</span><br><span class="line">        TrieNode** insert_pos = &amp;root;</span><br><span class="line">        TrieNode* parent_node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> curr_char = str[str.size()<span class="number">-1</span>-i];</span><br><span class="line">            <span class="keyword">while</span>(*insert_pos!=<span class="literal">nullptr</span> &amp;&amp; (*insert_pos)-&gt;this_char&lt;curr_char)</span><br><span class="line">                insert_pos = &amp;(*insert_pos)-&gt;sibling;</span><br><span class="line"></span><br><span class="line">            parent_node = *insert_pos;</span><br><span class="line">            <span class="keyword">if</span>(*insert_pos==<span class="literal">nullptr</span> || (*insert_pos)-&gt;this_char&gt;curr_char) &#123;</span><br><span class="line">                parent_node = get_node();</span><br><span class="line">                parent_node-&gt;sibling = *insert_pos;</span><br><span class="line">                parent_node-&gt;this_char = curr_char;</span><br><span class="line">                parent_node-&gt;height = i+<span class="number">1</span>;</span><br><span class="line">                *insert_pos = parent_node;</span><br><span class="line">            &#125;</span><br><span class="line">            insert_pos = &amp;parent_node-&gt;children;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(parent_node &amp;&amp; parent_node-&gt;pattern_end==<span class="literal">false</span>);</span><br><span class="line">        parent_node-&gt;pattern_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieNode* <span class="title">list_search</span><span class="params">(TrieNode* list_head, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(list_head &amp;&amp; list_head-&gt;this_char!=target)</span><br><span class="line">        list_head = list_head-&gt;sibling;</span><br><span class="line">    <span class="keyword">return</span> list_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_longest_trans_target</span><span class="params">(TrieNode* root)</span> </span>&#123;</span><br><span class="line">    assert(root!=<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">    TrieNode* current = root;</span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(current);</span><br><span class="line">        current = current-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs可以正确传递pattern_end标志, 但是需要使用queue实现。</span></span><br><span class="line">    <span class="comment">// 此处dfs。</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">        current = <span class="built_in">stack</span>.back();</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        TrieNode* children = current-&gt;children;</span><br><span class="line">        <span class="keyword">while</span>(children) &#123;</span><br><span class="line">            TrieNode* candidate = current-&gt;prefix;</span><br><span class="line">            <span class="keyword">while</span>(candidate &amp;&amp; children-&gt;prefix==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                children-&gt;prefix = list_search(candidate-&gt;children, children-&gt;this_char);</span><br><span class="line">                candidate = candidate-&gt;prefix;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(children-&gt;prefix==<span class="literal">nullptr</span>)</span><br><span class="line">                children-&gt;prefix = list_search(root, children-&gt;this_char);</span><br><span class="line">            assert(children-&gt;prefix!=children);</span><br><span class="line">            <span class="built_in">stack</span>.push_back(children);</span><br><span class="line">            TrieNode* prefix = children-&gt;prefix;</span><br><span class="line">            <span class="keyword">bool</span> pattern_end = children-&gt;pattern_end;</span><br><span class="line">            <span class="keyword">while</span>(prefix &amp;&amp; !pattern_end) &#123;</span><br><span class="line">                pattern_end = pattern_end || prefix-&gt;pattern_end;</span><br><span class="line">                prefix = prefix-&gt;prefix;</span><br><span class="line">            &#125;</span><br><span class="line">            children-&gt;pattern_end = pattern_end;</span><br><span class="line">            children = children-&gt;sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_tree</span><span class="params">(TrieNode* root, <span class="keyword">bool</span> newline=<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; root-&gt;this_char &lt;&lt; <span class="string">","</span> &lt;&lt; root-&gt;height &lt;&lt; <span class="string">","</span> </span><br><span class="line">            &lt;&lt; root-&gt;pattern_end &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">        print_tree(root-&gt;children, <span class="literal">false</span>);</span><br><span class="line">        root = root-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(newline) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ac-search-amp-test"><a href="#ac-search-amp-test" class="headerlink" title="ac-search &amp; test"></a>ac-search &amp; test</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_pattern_occurrence</span><span class="params">(TrieNode* suffix, <span class="keyword">const</span> <span class="built_in">string</span>&amp; haystack, <span class="keyword">int</span> pos, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&gt;=<span class="number">0</span> &amp;&amp; suffix; --i) &#123;</span><br><span class="line">        <span class="keyword">char</span> curr_char = haystack[i];</span><br><span class="line">        suffix = list_search(suffix, curr_char);</span><br><span class="line">        <span class="keyword">if</span>(suffix-&gt;pattern_end) &#123;</span><br><span class="line">            <span class="comment">// [i, pos+1) ~ [i, pos]</span></span><br><span class="line">            result.push_back(make_pair(i, pos+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        suffix = suffix-&gt;children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [begin_pos, end_pos)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ac_search(TrieNode* root, TrieNode* suffix, <span class="keyword">const</span> <span class="built_in">string</span>&amp; haystack) &#123;</span><br><span class="line">    assert(root!=<span class="literal">nullptr</span>);</span><br><span class="line">    assert(suffix!=<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    TrieNode* prev_matched = <span class="literal">nullptr</span>;</span><br><span class="line">    TrieNode* curr_matched = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;haystack.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> curr_char = haystack[i];</span><br><span class="line">        <span class="keyword">while</span>(prev_matched &amp;&amp; !curr_matched) &#123;</span><br><span class="line">            curr_matched = list_search(prev_matched-&gt;children, curr_char);</span><br><span class="line">            prev_matched = prev_matched-&gt;prefix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr_matched==<span class="literal">nullptr</span>)</span><br><span class="line">            curr_matched = list_search(root, curr_char);</span><br><span class="line">        <span class="keyword">if</span>(curr_matched &amp;&amp; curr_matched-&gt;pattern_end) &#123;</span><br><span class="line">            fill_pattern_occurrence(suffix, haystack, i, result);</span><br><span class="line">        &#125;</span><br><span class="line">        prev_matched = curr_matched;</span><br><span class="line">        curr_matched = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; patterns = &#123;</span><br><span class="line">        <span class="string">"announce"</span>,</span><br><span class="line">        <span class="string">"annual"</span>,</span><br><span class="line">        <span class="string">"annually"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">string</span> haystack = <span class="string">"annual_announce"</span>;</span><br><span class="line"></span><br><span class="line">    TrieNode* prefix = build_trie(patterns);</span><br><span class="line">    build_longest_trans_target(prefix);</span><br><span class="line">    TrieNode* suffix = build_suffix(patterns);</span><br><span class="line"></span><br><span class="line">    print_tree(prefix);</span><br><span class="line">    print_tree(suffix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = ac_search(prefix, suffix, haystack);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : result) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; item.first &lt;&lt; <span class="string">", "</span> &lt;&lt; item.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_trie(prefix);</span><br><span class="line">    free_trie(suffix);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：<a href="https://github.com/kmiku7/algorithms/blob/master/basic_ac_algorithm/main.cpp" target="_blank" rel="noopener">github</a></p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2015/04/25/basic-aho-corasick-algorithm/" data-id="cjdic4k620004oxs6wm1x0k22" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2015/04/25/basic-aho-corasick-algorithm/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ac-search/">ac-search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-structure/">data-structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/string-match/">string-match</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/trie/">trie</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zh/">zh</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode-combination-sum-ii" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/24/leetcode-combination-sum-ii/" class="article-date">
  <time datetime="2015-04-24T08:20:37.000Z" itemprop="datePublished">Apr 24 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/24/leetcode-combination-sum-ii/">LeetCode - Combination Sum II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Combination Sum II </p>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.<br>Each number in C may only be used once in the combination.</p>
</blockquote>
<p>先对C里的数字计数，然后递归处理，每个数字出现[0, count[num]]次。<br>自己写了个AVL树作为map计数。然后没有维护unique-number的列表，把AVL树先转成线索二叉树，然后遍历，结束后再转回普通树结构。不要问我为啥这么写，闲的。  </p>
<h4 id="AVL-Tree实现"><a href="#AVL-Tree实现" class="headerlink" title="AVL Tree实现"></a>AVL Tree实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> AVLTREE_MAX_HEIGHT = <span class="number">62</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVLTreeNode</span> &#123;</span></span><br><span class="line">    AVLTreeNode* left;</span><br><span class="line">    AVLTreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">size_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    AVLTreeNode(<span class="keyword">size_t</span> k=<span class="number">0</span>, <span class="keyword">int</span> v=<span class="number">0</span>) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), height(<span class="number">1</span>), key(k), value(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avl_height</span><span class="params">(AVLTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root?root-&gt;height:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avl_height_update</span><span class="params">(AVLTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert(root!=NULL);</span></span><br><span class="line">    <span class="keyword">return</span> (root-&gt;height = <span class="built_in">std</span>::max(avl_height(root-&gt;left), avl_height(root-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avl_balance_factor</span><span class="params">(AVLTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert(root!=NULL);</span></span><br><span class="line">    <span class="keyword">return</span> avl_height(root-&gt;left) - avl_height(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTreeNode* <span class="title">avl_rotate_left</span><span class="params">(AVLTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert(root!=nullptr);</span></span><br><span class="line">    AVLTreeNode* right = root-&gt;right;</span><br><span class="line">    <span class="comment">// assert(right!=nullptr);</span></span><br><span class="line">    root-&gt;right= right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line">    avl_height_update(root);</span><br><span class="line">    avl_height_update(right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTreeNode* <span class="title">avl_rotate_right</span><span class="params">(AVLTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert(root!=nullptr);</span></span><br><span class="line">    AVLTreeNode* left = root-&gt;left;</span><br><span class="line">    <span class="comment">// assert(right!=nullptr);</span></span><br><span class="line">    root-&gt;left = left-&gt;right;</span><br><span class="line">    left-&gt;right = root;</span><br><span class="line">    avl_height_update(root);</span><br><span class="line">    avl_height_update(left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true:    insert;</span></span><br><span class="line"><span class="comment">// false:   update;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">avl_insert</span><span class="params">(AVLTreeNode*&amp; root, <span class="keyword">size_t</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    AVLTreeNode* path[AVLTREE_MAX_HEIGHT] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> top_pos = <span class="number">1</span>;</span><br><span class="line">    AVLTreeNode* curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        path[top_pos++] = curr;</span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;key&gt;key) &#123;</span><br><span class="line">            curr = curr-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr-&gt;key&lt;key) &#123;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr-&gt;value = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = <span class="keyword">new</span> AVLTreeNode(key, value);</span><br><span class="line">    AVLTreeNode* parent = path[--top_pos];</span><br><span class="line">    <span class="keyword">if</span>(parent==<span class="literal">nullptr</span>) root = curr;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;key&lt;key) parent-&gt;right = curr;</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;left = curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(parent!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent_balance_factor = avl_balance_factor(parent);</span><br><span class="line">        <span class="keyword">int</span> curr_balance_factor = avl_balance_factor(curr);</span><br><span class="line">        <span class="keyword">if</span>(parent_balance_factor==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr_balance_factor==<span class="number">-1</span>) &#123;</span><br><span class="line">                curr = avl_rotate_left(curr);</span><br><span class="line">                parent-&gt;left = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AVLTreeNode** p_parent_parent = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]==<span class="literal">nullptr</span>)</span><br><span class="line">                p_parent_parent = &amp;root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]-&gt;left == parent)</span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;right;</span><br><span class="line"></span><br><span class="line">            parent = avl_rotate_right(parent);</span><br><span class="line">            *p_parent_parent = parent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parent_balance_factor==<span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr_balance_factor==<span class="number">1</span>) &#123;</span><br><span class="line">                curr = avl_rotate_right(curr);</span><br><span class="line">                parent-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AVLTreeNode** p_parent_parent = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]==<span class="literal">nullptr</span>)</span><br><span class="line">                p_parent_parent = &amp;root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]-&gt;left == parent)</span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;right;</span><br><span class="line"></span><br><span class="line">            parent = avl_rotate_left(parent);</span><br><span class="line">            *p_parent_parent = parent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parent_balance_factor==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        avl_height_update(parent);</span><br><span class="line">        curr = parent;</span><br><span class="line">        parent = path[--top_pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">avl_search</span><span class="params">(AVLTreeNode* <span class="keyword">const</span> root, <span class="keyword">size_t</span> key, <span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    AVLTreeNode* temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;key==key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(value) *value = temp-&gt;value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;key &lt; key) &#123;</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">avl_delete</span><span class="params">(AVLTreeNode*&amp; root, <span class="keyword">size_t</span> key, <span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    AVLTreeNode* path[AVLTREE_MAX_HEIGHT] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> top_pos = <span class="number">1</span>;</span><br><span class="line">    AVLTreeNode* curr = root;</span><br><span class="line">    AVLTreeNode* remove = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;key==key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        path[top_pos++] = curr;</span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;key&gt;key)</span><br><span class="line">            curr = curr-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            curr =curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    remove = curr;</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; curr-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        remove = curr-&gt;left;</span><br><span class="line">        path[top_pos++] = curr;</span><br><span class="line">        <span class="keyword">while</span>(remove-&gt;right) &#123;</span><br><span class="line">            path[top_pos++] = remove;</span><br><span class="line">            remove = remove-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVLTreeNode* parent = path[--top_pos];</span><br><span class="line">    <span class="keyword">if</span>(parent==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// assert(remove==curr);</span></span><br><span class="line">        root = remove-&gt;left ? remove-&gt;left : remove-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span>(remove);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(remove!=curr) &#123;</span><br><span class="line">        curr-&gt;key = remove-&gt;key;</span><br><span class="line">        curr-&gt;value = remove-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = remove-&gt;left ? remove-&gt;left : remove-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(remove==parent-&gt;left)</span><br><span class="line">        parent-&gt;left = curr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent-&gt;right = curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(remove);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(parent!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        parent-&gt;height = avl_height_update(parent);</span><br><span class="line">        <span class="keyword">int</span> parent_balance_factor = avl_balance_factor(parent);</span><br><span class="line">        <span class="keyword">if</span>(parent_balance_factor==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr_balance_factor = avl_balance_factor(parent-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(curr_balance_factor==<span class="number">-1</span>)</span><br><span class="line">                parent-&gt;left = avl_rotate_left(parent-&gt;left);</span><br><span class="line"></span><br><span class="line">            AVLTreeNode** p_parent_parent = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]==<span class="literal">nullptr</span>)</span><br><span class="line">                p_parent_parent = &amp;root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]-&gt;left == parent)</span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;right;</span><br><span class="line"></span><br><span class="line">            parent = avl_rotate_right(parent);</span><br><span class="line">            *p_parent_parent = parent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parent_balance_factor==<span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr_balance_factor = avl_balance_factor(parent-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr_balance_factor==<span class="number">1</span>)</span><br><span class="line">                parent-&gt;right = avl_rotate_right(parent-&gt;right);</span><br><span class="line"></span><br><span class="line">            AVLTreeNode** p_parent_parent = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]==<span class="literal">nullptr</span>)</span><br><span class="line">                p_parent_parent = &amp;root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path[top_pos<span class="number">-1</span>]-&gt;left == parent)</span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_parent_parent = &amp;path[top_pos<span class="number">-1</span>]-&gt;right;</span><br><span class="line"></span><br><span class="line">            parent = avl_rotate_left(parent);</span><br><span class="line">            *p_parent_parent = parent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parent_balance_factor == <span class="number">1</span> || parent_balance_factor == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        avl_height_update(parent);</span><br><span class="line">        parent = path[--top_pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目实现"><a href="#题目实现" class="headerlink" title="题目实现"></a>题目实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        AVLTreeNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item: num) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> ret = avl_search(head, item, &amp;value);</span><br><span class="line">            avl_insert(head, item, value+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buffer;</span><br><span class="line">        buffer.reserve(num.size()/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将二叉树转成线索二叉树，然后再转换回来。</span></span><br><span class="line">        <span class="comment">// trans to threaded thee;</span></span><br><span class="line">        AVLTreeNode* curr = head;</span><br><span class="line">        AVLTreeNode* thread_head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(thread_head==<span class="literal">nullptr</span>) thread_head = curr;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            AVLTreeNode* left = curr-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(left-&gt;right &amp;&amp; left-&gt;right!=curr) left = left-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                left-&gt;right = curr;</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(thread_head, target, buffer, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unthread</span></span><br><span class="line">        curr = thread_head;</span><br><span class="line">        <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            AVLTreeNode* left = curr-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(left-&gt;right &amp;&amp; left-&gt;right!=curr) left = left-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;right == curr) &#123;</span><br><span class="line">                left-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(<span class="literal">false</span> &amp;&amp; <span class="string">"should not here"</span>);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(AVLTreeNode* head, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tpl, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> num = head-&gt;key;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        AVLTreeNode* next = head-&gt;right;</span><br><span class="line">        AVLTreeNode* left = next ? next-&gt;left : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(left) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left-&gt;right &amp;&amp; left-&gt;right!=next) left = left-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(left != head) &#123;</span><br><span class="line">                <span class="keyword">while</span>(next-&gt;left) next = next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>) result.push_back(tpl);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num) dfs(next, target, tpl, result);</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">            tpl.push_back(num);</span><br><span class="line">            target -= num;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;=head-&gt;value &amp;&amp; target &gt;=<span class="number">0</span>);</span><br><span class="line">        tpl.resize(tpl.size()-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">6</span>;</span><br><span class="line">    Solution s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = s.combinationSum2(nums, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : result) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size("</span> &lt;&lt; item.size() &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val : item) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始是用它解Word Break的，但是hash冲突了，我也懒得再给TreeNode补个开链实现。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2015/04/24/leetcode-combination-sum-ii/" data-id="cjdic4k6d000eoxs69y8cq4ve" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2015/04/24/leetcode-combination-sum-ii/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/avl-tree/">avl-tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-structure/">data-structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/morris-travesal/">morris-travesal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threaded-binary-tree/">threaded-binary-tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zh/">zh</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-the-obscure-in-python-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/06/the-obscure-in-python-thread/" class="article-date">
  <time datetime="2015-01-05T16:10:41.000Z" itemprop="datePublished">Jan 6 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/06/the-obscure-in-python-thread/">Python线程的隐晦之处</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记几点python多线程使用里需要注意的地方。</p>
<h3 id="thread-stack-size-size"><a href="#thread-stack-size-size" class="headerlink" title="thread.stack_size([size])"></a>thread.stack_size([size])</h3><p>这是module thread提供的接口，该函数每次调用时都会设置stack size，不加参数就设置stack size为0，也就是使用系统默认值，返回值是之前stack size的“旧值”。不要以为不加参数仅仅是返回stack size。 </p>
<h3 id="thread-local-threading-local-threading-local"><a href="#thread-local-threading-local-threading-local" class="headerlink" title="thread._local, _threading_local, threading.local"></a>thread._local, _threading_local, threading.local</h3><p>thread._local和_threading_local是原始实现， threading提供的只是个alias。mannual page: <a href="https://docs.python.org/2/library/threading.html#threading.local" target="_blank" rel="noopener">link</a>.</p>
<p>_local()每次都会产生一个全新的localobject，实现方式是新建一个localobject，内部封装一个dict，然后对localobject的属性查找都在封装的dict里进行，同时dict也以threadid为key存储在PyThreadState/threading.Thread的dict属性里。没啥用。<br>使用过程中需要由用户持有对localobject的引用，一旦释放localobject也就被析构了，内部存储的数据也会被析构，也就是不能像以下代码里这样用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_a</span><span class="params">()</span>:</span></span><br><span class="line">    tss =thread._local()</span><br><span class="line">    tss.var = tss.var + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_b</span><span class="params">()</span>:</span></span><br><span class="line">    tss = thread._local()</span><br><span class="line">    <span class="keyword">print</span> tss.var</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_proc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        func_a()</span><br><span class="line">        func_b()</span><br></pre></td></tr></table></figure></p>
<p>也就是他无法提供一个线程级的__builtins__ namespace空间。thread._local支持的功能用户可以用更加清晰的方式自己实现。</p>
<h3 id="基于linux实现的thread-module是detach的。"><a href="#基于linux实现的thread-module是detach的。" class="headerlink" title="基于linux实现的thread module是detach的。"></a>基于linux实现的thread module是detach的。</h3><p>其他系统有没有detach这个概念不清楚了。</p>
<h3 id="threading的线程安全性。"><a href="#threading的线程安全性。" class="headerlink" title="threading的线程安全性。"></a>threading的线程安全性。</h3><p>我竟然在说线程库的线程安全性（囧<br>每个threading.Thread()是有个thread-name的，如果初始化参数没有提供会使用如下函数进行生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: threading.py</span></span><br><span class="line">_counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_newname</span><span class="params">(template=<span class="string">"Thread-%d"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _counter</span><br><span class="line">    _counter = _counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> template % _counter</span><br></pre></td></tr></table></figure></p>
<p>threading是python实现的，这段代码也不是线程安全的，生成的thread-name有可能重复。所以还是自己设置thread name吧。<br>可以执行这个脚本测下，输出的thread name是有重复的，我的测试版本是cpython 2.7.5。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.setcheckinterval(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.level = level</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> self.getName()</span><br><span class="line">        <span class="keyword">if</span> self.level &gt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        thread_a = MyThread(self.level+<span class="number">1</span>)</span><br><span class="line">        thread_b = MyThread(self.level+<span class="number">1</span>)</span><br><span class="line">        thread_a.start()</span><br><span class="line">        thread_b.start()</span><br><span class="line"></span><br><span class="line">thread = MyThread(<span class="number">1</span>)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>###importing in threaded code<br>from mannual, <a href="https://docs.python.org/2/library/threading.html#importing-in-threaded-code" target="_blank" rel="noopener">link</a>.</p>
<blockquote>
<p>Firstly, other than in the main module, an import should not have the side effect of spawning a new thread and then waiting for that thread in any way. Failing to abide by this restriction can lead to a deadlock if the spawned thread directly or indirectly attempts to import a module.  </p>
</blockquote>
<p>这条说的是import的时候，要导入的module如果另起一个线程并等待该线程做某些事情，同时该线程里又要执行import操作，这样会导致死锁，main thread也不行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: import.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyImport_ImportModuleLevel(<span class="keyword">char</span> *name, PyObject *globals, PyObject *locals,</span><br><span class="line">             PyObject *fromlist, <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result;</span><br><span class="line">    lock_import();</span><br><span class="line">    result = import_module_level(name, globals, locals, fromlist, level);</span><br><span class="line">    <span class="keyword">if</span> (unlock_import() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_XDECREF(result);</span><br><span class="line">        PyErr_SetString(PyExc_RuntimeError,</span><br><span class="line">                <span class="string">"not holding the import lock"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是cpython的import功能实现代码，虚拟机经过一系列调用到这个函数真正开始import操作。其中的lock_import() &amp; unlock_import()实现了reentrant lock的功能。原因很清楚，虚拟机是字节码级别的中断，该函数是import_name的实现，可以认为是原子的，函数里加的锁不会随着GIL的释放而释放。<br>死锁模拟代码：<a href="https://github.com/kmiku7/python-2.5-annotated/tree/master/code-reading/thread_import" target="_blank" rel="noopener">link</a></p>
<blockquote>
<p>Secondly, all import attempts must be completed before the interpreter starts shutting itself down. This can be most easily achieved by only performing imports from non-daemon threads created through the threading module. Daemon threads and threads created directly with the thread module will require some other form of synchronization to ensure they do not attempt imports after system shutdown has commenced. Failure to abide by this restriction will lead to intermittent exceptions and crashes during interpreter shutdown (as the late imports attempt to access machinery which is no longer in a valid state).  </p>
</blockquote>
<p>这个说的比较清楚了。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2015/01/06/the-obscure-in-python-thread/" data-id="cjdic4k6m000poxs68jn4c53r" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2015/01/06/the-obscure-in-python-thread/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threading/">threading</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zh/">zh</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-libchan-code-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/21/libchan-code-analysis/" class="article-date">
  <time datetime="2014-11-21T01:41:58.000Z" itemprop="datePublished">Nov 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/21/libchan-code-analysis/">libchan实现分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>libchan是docker衍生出来的子模块，用来在goroutine间、进程间、机器间提供相同的类似go channel的通信方式，<strong>每个channal是单工的</strong>，方便程序从多goroutine到多进程再到多机的扩展。使用上跟linux pipe类似。</p>
<p>项目地址： <a href="https://github.com/docker/libchan" target="_blank" rel="noopener">https://github.com/docker/libchan</a><br>代码版本：commit 1e141b35ee</p>
<p>这是项目里提到的功能：  </p>
<ol>
<li>Simple message passing  </li>
<li>Synchronization for concurrent programming  </li>
<li>Nesting: channels can send channels<br>1/3是可以理解的，2有一点疑问，可以参考项目issue里的讨论。</li>
</ol>
<p>使用方法参考项目里的demo： <a href="https://github.com/docker/libchan/tree/master/examples/rexec" target="_blank" rel="noopener">https://github.com/docker/libchan/tree/master/examples/rexec</a></p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>项目里目前提供了基于tcp/spdy和inmem两种实现，每种实现只需实现以下接口即可：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">interface</span> &#123;</span><br><span class="line">    NewSendChannel() (Sender, error)</span><br><span class="line">    WaitReceiveChannel() (Receiver, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Sender <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(message <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Receiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Receive(message <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inmem没有提供Transport，是通过Pipe()函数成生的sender &amp; receiver，因此spdy/inmen的实现在channel初始化的时候稍有不同。</p>
<h3 id="可打包传输的数据类型"><a href="#可打包传输的数据类型" class="headerlink" title="可打包传输的数据类型"></a>可打包传输的数据类型</h3><p>数据传输使用<a href="https://github.com/dmcgowan/go" target="_blank" rel="noopener">github.com/dmcgowan/go/codec</a>进行编码，打包格式用的msgpack。<br>codec默认支持以下数据类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: https://github.com/dmcgowan/go/blob/master/codec/encode.go</span></span><br><span class="line"><span class="comment">// encDriver abstracts the actual codec (binc vs msgpack, etc)</span></span><br><span class="line"><span class="keyword">type</span> encDriver <span class="keyword">interface</span> &#123;</span><br><span class="line">    isBuiltinType(rt <span class="keyword">uintptr</span>) <span class="keyword">bool</span></span><br><span class="line">    encodeBuiltin(rt <span class="keyword">uintptr</span>, v <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    encodeNil()</span><br><span class="line">    encodeInt(i <span class="keyword">int64</span>)</span><br><span class="line">    encodeUint(i <span class="keyword">uint64</span>)</span><br><span class="line">    encodeBool(b <span class="keyword">bool</span>)</span><br><span class="line">    encodeFloat32(f <span class="keyword">float32</span>)</span><br><span class="line">    encodeFloat64(f <span class="keyword">float64</span>)</span><br><span class="line">    encodeExtPreamble(xtag <span class="keyword">byte</span>, length <span class="keyword">int</span>)</span><br><span class="line">    encodeArrayPreamble(length <span class="keyword">int</span>)</span><br><span class="line">    encodeMapPreamble(length <span class="keyword">int</span>)</span><br><span class="line">    encodeString(c charEncoding, v <span class="keyword">string</span>)</span><br><span class="line">    encodeSymbol(v <span class="keyword">string</span>)</span><br><span class="line">    encodeStringBytes(c charEncoding, v []<span class="keyword">byte</span>)</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="comment">//encBignum(f *big.Int)</span></span><br><span class="line">    <span class="comment">//encStringRunes(c charEncoding, v []rune)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>codec支持扩展，可以注册其他数据类型的编解码句柄。libchan扩展支持Sender/Receiver/io.ReadWriteCloser/io.ReadCloser/io.WriteCloser的打包传输。<br>TCPConn &amp; UDPConn属于io.ReadWriteCloser类型，spdy实现只能传输建立在sender&amp;receiver所在主机之间的连接。</p>
<p>io对象传输的实现流程是：</p>
<ul>
<li>sender端需要打包发送io句柄A  </li>
<li>在sender&amp;receiver之间建立通信管道P(P-Sender, P-Receiver)，inmem、spdy分别使用net.Pipe和spdy.stream建立。  </li>
<li>sender起goroutine在A &amp; P-Sender间进行数据拷贝，发送管道P的ID，receiver端对P-receiver进行读写。 </li>
</ul>
<p>操作完成后的情况如下图：</p>
<p><img src="/img/libchan-send-io.png" alt="" title="libchan-send-io.png"></p>
<p>###代码分析</p>
<p>####inmem<br>每一对sender&amp;receiver都有与之关联的一个session数据结构，用来管理通过该chan传输的sender、receiver、io对象等。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> streamSession <span class="keyword">struct</span> &#123;</span><br><span class="line">    pipeLock    sync.Mutex</span><br><span class="line">    pipeCount   <span class="keyword">uint64</span></span><br><span class="line">    pipeReaders <span class="keyword">map</span>[<span class="keyword">uint64</span>]*io.PipeReader</span><br><span class="line">    pipeWriters <span class="keyword">map</span>[<span class="keyword">uint64</span>]*io.PipeWriter</span><br><span class="line"></span><br><span class="line">    handler codec.Handle</span><br><span class="line"></span><br><span class="line">    referenceLock sync.Mutex</span><br><span class="line">    referenceID   <span class="keyword">uint64</span></span><br><span class="line">    byteStreams   <span class="keyword">map</span>[<span class="keyword">uint64</span>]*byteStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handler是一个codec编解码句柄。<br>io对象的传输是通过net.Pipe()创建的管道和sender端的proxy实现，IO通道存储在byteStreams字段里，net.Pipe()返回两个句柄，对应两个byteStream对象，分别存储在map[ref_ID] map[ref_ID+1]里，本地使用map[ref_ID]进行读写，传输ref_ID+1给对端，对端使用map[ref_ID+1]的对象读写。<br>io.ReadClose &amp; io.WriteClose &amp; io.ReadWriteCloser实现方式相同，只是在sender端起的proxy routine不同。byteStream是可读写的，根据存储byteStream对象的字段类型的不同会表现出只读、只写、读写的不同特征。</p>
<p>Sender &amp; Receiver通过io.Pipe()传输数据，返回的通道是单工的，读写两端分别存储在pipeReaders &amp; pipeWriters字段里。S &amp; R传输处理流程类似，比如senderA.send(otherB)，如果senderB属于senderA的session，则直接传输对应的map-key，如果不是则新建一个io.Pipe，通过goroutine io.copy实现转发。</p>
<p>接下来分析下io.ReadWriteCloser、Sender对象编码传输、解码使用的流程。</p>
<p>#####临时对象构造<br>首先对要传输的对象构造出来一个临时的拷贝，其中的io.ReadWriteCloser/Sender转换成内部对应的bytesStream对象和同session的Sender，如有需要，转发的proxy都已启动。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copyValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> val := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> *pipeSender:</span><br><span class="line">        <span class="keyword">if</span> val.session != w.session &#123;</span><br><span class="line">            <span class="keyword">return</span> w.copySender(val)</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> io.ReadWriteCloser:</span><br><span class="line">        <span class="keyword">return</span> w.copyByteStream(val)</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copyByteStream行为是在该session内新建一个net.Pipe，然后启动转发的proxy-routine。newByteStream()创建一对byteStream对象代表net.Pipe的两端，存储在byteStreams字段里，id分别为referenceID和referenceID+1，referenceID+1给对端使用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copyByteStream</span><span class="params">(stream io.ReadWriteCloser)</span> <span class="params">(io.ReadWriteCloser, error)</span></span> &#123;</span><br><span class="line">    streamCopy, err := w.session.newByteStream()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(streamCopy, stream)</span><br><span class="line">        streamCopy.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(stream, streamCopy)</span><br><span class="line">        stream.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> streamCopy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">newByteStream</span><span class="params">()</span> <span class="params">(io.ReadWriteCloser, error)</span></span> &#123;</span><br><span class="line">    c1, c2 := net.Pipe()</span><br><span class="line">    bs := &amp;byteStream&#123;</span><br><span class="line">        Conn:        c1,</span><br><span class="line">        referenceID: s.referenceID,</span><br><span class="line">        session:     s,</span><br><span class="line">    &#125;</span><br><span class="line">    s.referenceLock.Lock()</span><br><span class="line">    s.byteStreams[s.referenceID] = bs</span><br><span class="line">    s.byteStreams[s.referenceID+<span class="number">1</span>] = &amp;byteStream&#123;</span><br><span class="line">        Conn:        c2,</span><br><span class="line">        referenceID: s.referenceID + <span class="number">1</span>,</span><br><span class="line">        session:     s,</span><br><span class="line">    &#125;</span><br><span class="line">    s.referenceID = s.referenceID + <span class="number">2</span></span><br><span class="line">    s.referenceLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copySender()行为类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copySender</span><span class="params">(val Sender)</span> <span class="params">(Sender, error)</span></span> &#123;</span><br><span class="line">    recv, send, err := w.CreateNestedReceiver()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Copy(val, recv)</span><br><span class="line">        val.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> send, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####序列化<br>byteStream和Sender使用注册的codec扩展句柄编码，byteStream编码函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">encodeStream</span><span class="params">(v reflect.Value)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    bs := v.Interface().(byteStream)</span><br><span class="line">    <span class="keyword">if</span> bs.referenceID == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"bad type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    written := binary.PutUvarint(buf[:], <span class="keyword">uint64</span>(bs.referenceID)^<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf[:written], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStream每次都创建一对，并且referenceID从2顺序使用，因此本端对象的referenceID总是偶数，对端使用referenceID+1存储的byteStream，uint64(bs.referenceID)^0x01等价于bs.referenceID+1，这个地方太绕了。<br>encodeSender()编码Sender对象，行为类似。</p>
<p>#####反序列化<br>对于一个整数，反序列化后的类型取决于存储他的对象类型，所以收发两端的数据结构不对应就会出错。byteStream反序列化逻辑如下，Sender处理逻辑类似。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">decodeStream</span><span class="params">(v reflect.Value, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    referenceID, readN := binary.Uvarint(b)</span><br><span class="line">    <span class="keyword">if</span> readN == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"bad reference id"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs, ok := s.byteStreams[referenceID]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"byte stream does not exist"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bs != <span class="literal">nil</span> &#123;</span><br><span class="line">        v.Set(reflect.ValueOf(*bs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStream结构体嵌入了net.Conn，因此是一个io.ReadWriteClose对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byteStream <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    referenceID <span class="keyword">uint64</span></span><br><span class="line">    session     *streamSession</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####spdy<br>这是一个基于tcp+spdy作为传输层的实现，每一对sender&amp;receiver或io对象都对应spdy的一个stream。spdy实现了Transport，也使用该数据结构管理在一个chan间传输的sub-chan、io对象的信息。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    *spdystream.Connection</span><br><span class="line">    handler codec.Handle</span><br><span class="line"></span><br><span class="line">    receiverChan <span class="keyword">chan</span> *channel</span><br><span class="line">    channelC     *sync.Cond</span><br><span class="line">    channels     <span class="keyword">map</span>[<span class="keyword">uint64</span>]*channel</span><br><span class="line"></span><br><span class="line">    referenceLock    sync.Mutex</span><br><span class="line">    referenceCounter <span class="keyword">uint64</span></span><br><span class="line">    byteStreamC      *sync.Cond</span><br><span class="line">    byteStreams      <span class="keyword">map</span>[<span class="keyword">uint64</span>]*byteStream</span><br><span class="line"></span><br><span class="line">    netConnC *sync.Cond</span><br><span class="line">    netConns <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn</span><br><span class="line">    networks <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> channel <span class="keyword">struct</span> &#123;</span><br><span class="line">    referenceID <span class="keyword">uint64</span></span><br><span class="line">    parentID    <span class="keyword">uint64</span></span><br><span class="line">    stream      *spdystream.Stream</span><br><span class="line">    session     *Transport</span><br><span class="line">    direction   direction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStreams存储io对象转发的通道，使用TCPConn传输，因此是双工的。怎么使用依赖于持有他的对象。<br>channels存储两机间的chan通道。channel封装了一个byteStream对象和direction字段，因此只能单向使用。</p>
<p>因为Sender&amp;Receiver和io对象都通过spdy的stream实现，所以stream建立的时候就需要进行区分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">newStreamHandler</span><span class="params">(stream *spdystream.Stream)</span></span> &#123;</span><br><span class="line">    referenceIDString := stream.Headers().Get(<span class="string">"libchan-ref"</span>)</span><br><span class="line">    parentIDString := stream.Headers().Get(<span class="string">"libchan-parent-ref"</span>)</span><br><span class="line"></span><br><span class="line">    returnHeaders := http.Header&#123;&#125;</span><br><span class="line">    finish := <span class="literal">false</span></span><br><span class="line">    referenceID, parseErr := strconv.ParseUint(referenceIDString, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> parseErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"400"</span>)</span><br><span class="line">        finish = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parentIDString区分了channel和stream</span></span><br><span class="line">        <span class="keyword">if</span> parentIDString == <span class="string">""</span> &#123;</span><br><span class="line">            byteStream := &amp;byteStream&#123;</span><br><span class="line">                referenceID: referenceID,</span><br><span class="line">                stream:      stream,</span><br><span class="line">                session:     s,</span><br><span class="line">            &#125;</span><br><span class="line">            s.byteStreamC.L.Lock()</span><br><span class="line">            s.byteStreams[referenceID] = byteStream</span><br><span class="line">            s.byteStreamC.Broadcast()</span><br><span class="line">            s.byteStreamC.L.Unlock()</span><br><span class="line"></span><br><span class="line">            returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"200"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentID, parseErr := strconv.ParseUint(parentIDString, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">            <span class="keyword">if</span> parseErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"400"</span>)</span><br><span class="line">                finish = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c := &amp;channel&#123;</span><br><span class="line">                    referenceID: referenceID,</span><br><span class="line">                    parentID:    parentID,</span><br><span class="line">                    stream:      stream,</span><br><span class="line">                    session:     s,</span><br><span class="line">                &#125;</span><br><span class="line">                s.channelC.L.Lock()</span><br><span class="line">                s.channels[referenceID] = c</span><br><span class="line">                s.channelC.Broadcast()</span><br><span class="line">                s.channelC.L.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// subchannel是没有方向概念的</span></span><br><span class="line">                <span class="keyword">if</span> parentID == <span class="number">0</span> &#123;</span><br><span class="line">                    c.direction = inbound</span><br><span class="line">                    s.receiverChan &lt;- c</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"200"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream.SendReply(returnHeaders, finish)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果parentIDString为空，则是一个byteStream，该stream只读、只写、读写是由持有他的对象决定的。parentIDString非空且不等于0，则是在两机间新建一个管道，创建总是由sender端发起；如果不等于，则是一个subchannel，该chan用来发送还是接收是由持有他的对象决定的。</p>
<p>spdy实现在函数initializeHandler()注册的扩展类型编解码句柄：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">initializeHandler</span><span class="params">()</span> *<span class="title">codec</span>.<span class="title">MsgpackHandle</span></span> &#123;</span><br><span class="line">    mh := &amp;codec.MsgpackHandle&#123;WriteExt: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register networks</span></span><br><span class="line">    s.networks[<span class="string">"tcp"</span>] = <span class="number">0x04</span></span><br><span class="line">    s.netConns[<span class="number">0x04</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn)</span><br><span class="line">    err = mh.AddExt(reflect.TypeOf(net.TCPConn&#123;&#125;), <span class="number">0x04</span>, s.encodeNetConn, s.decodeNetConn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.networks[<span class="string">"udp"</span>] = <span class="number">0x05</span></span><br><span class="line">    s.netConns[<span class="number">0x05</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn)</span><br><span class="line">    err = mh.AddExt(reflect.TypeOf(net.UDPConn&#123;&#125;), <span class="number">0x05</span>, s.encodeNetConn, s.decodeNetConn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO add unix network as 0x06</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比inmem增加了TCPConn和UDPConn的额外处理。因此这也限制了spdy只能传输在两机间建立的连接，且接收端已经将该conn注册到这个session内。<br>这是代码中的注释：</p>
<blockquote>
<p>// RegisterConn registers a network connection to be used<br>// by inbound messages referring to the connection<br>// with the registered connection&#39;s local and remote address.<br>// Note: a connection does not need to be registered before<br>// being sent in a message, but does need to be registered<br>// to by the receiver of a message. If registration should be<br>// automatic, register a listener instead.  </p>
</blockquote>
<p>注册的连接保存在netConns字段内，使用二维map存储：map[network-type][localaddr&lt;&gt;remoteaddr]。传输时编码的是一个三元组(network-type, local-addr, remote-addr) 。实现函数是<em>encodeNetConn(), decodeNetConn()</em>，注意解码时的字段顺序。</p>
<p>网络连接的传输可以参考这个测试用例：<a href="https://github.com/docker/libchan/blob/master/spdy/conn_test.go" target="_blank" rel="noopener">https://github.com/docker/libchan/blob/master/spdy/conn_test.go</a></p>
<p>###summary<br>总体来说channel通信方式使用很直观方便，屏蔽了底层的通信建立细节。但是实现方式不容易理解，看了spdy代码也不放心，出了问题debug有困难，比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">getByteStream</span><span class="params">(referenceID <span class="keyword">uint64</span>)</span> *<span class="title">byteStream</span></span> &#123;</span><br><span class="line">    s.byteStreamC.L.Lock()</span><br><span class="line">    bs, ok := s.byteStreams[referenceID]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        s.byteStreamC.Wait()</span><br><span class="line">        bs, ok = s.byteStreams[referenceID]</span><br><span class="line">    &#125;</span><br><span class="line">    s.byteStreamC.L.Unlock()</span><br><span class="line">    <span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>if是不是应该换成while判断。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/11/21/libchan-code-analysis/" data-id="cjdic4k6h000koxs6g6zbjiwk" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/11/21/libchan-code-analysis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code-analysis/">code-analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libchan/">libchan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zh/">zh</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode-sort-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/16/leetcode-sort-list/" class="article-date">
  <time datetime="2014-11-16T06:42:25.000Z" itemprop="datePublished">Nov 16 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/interview/">interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/16/leetcode-sort-list/">LeetCode - Sort List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Sort List<br>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>
<p>排序一个单向链表，要求时间复杂度O(nlgn)，空间复杂度O(1)。使用merge sort解该问题，网上的答案用的都是递归的解法，也就是top-down的实现，空间复杂度应该为O(lgn)，并不是常数，使用bottom-up的实现可以达到O(1)的空间复杂度。</p>
<p><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">wikipedia</a>只给出了数组的top-down &amp; bottom-up实现和list的top-down实现。<br>这里的快慢指针技巧非常有用：<a href="http://www.cnblogs.com/x1957/p/3492219.html" target="_blank" rel="noopener">link1</a> <a href="http://blog.csdn.net/jiadebin890724/article/details/21334059" target="_blank" rel="noopener">link2</a>。<br>链表的实现有带头节点和不带头节点两种形式，不带头节点的实现需要判断head==NULL的情况，带头节点则会浪费一个节点的空间。对于不带头节点的链表，各个操作可以用二级指针实现，把代码书写上的复杂度转移到coder的脑袋里。</p>
<h3 id="Talk-is-cheap-show-you-the-code"><a href="#Talk-is-cheap-show-you-the-code" class="headerlink" title="Talk is cheap, show you the code:"></a>Talk is cheap, show you the code:</h3><p>两个bottom-up的实现，第一个空间复杂度O(n)，最多需要存储n/2个链表头指针。</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1."></a>Code 1.</h4><p>这里的queue使用list会超时。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="built_in">deque</span>&lt;ListNode*&gt; <span class="built_in">queue</span>;</span><br><span class="line">        ListNode* iter = head;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.push_back(iter);</span><br><span class="line">            next = iter-&gt;next;</span><br><span class="line">            iter-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            iter = next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            iter = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop_front();</span><br><span class="line">            next = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop_front();</span><br><span class="line">            <span class="built_in">queue</span>.push_back(mergeList(iter, next));</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.front();   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* merged_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** next_holder = &amp;merged_list;</span><br><span class="line">        ListNode* selected_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                selected_node = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected_node = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;   </span><br><span class="line">            selected_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *next_holder = selected_node;</span><br><span class="line">            next_holder = &amp;(selected_node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        *next_holder = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> merged_list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code 2."></a>Code 2.</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(head != NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = length(head);</span><br><span class="line">        ListNode* sorted_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** tail_holder = &amp;sorted_list;</span><br><span class="line">        <span class="keyword">while</span> (step &lt; len) &#123;</span><br><span class="line">            ListNode* left_head = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* left_tail = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* right_head = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* right_tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            cutList(head, step, &amp;left_head, &amp;left_tail, &amp;head);</span><br><span class="line">            left_tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *tail_holder = left_head;</span><br><span class="line">                <span class="keyword">goto</span> NEXT_LOOP;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            cutList(head, step, &amp;right_head, &amp;right_tail, &amp;head);</span><br><span class="line">            right_tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *tail_holder = mergeList(left_head, right_head);</span><br><span class="line">            <span class="comment">//assert( (left_tail-&gt;next == NULL &amp;&amp; right_tail-&gt;next != NULL)</span></span><br><span class="line">            <span class="comment">//        || (left_tail-&gt;next != NULL &amp;&amp; right_tail-&gt;next == NULL));</span></span><br><span class="line">            <span class="keyword">if</span> (right_tail-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tail_holder = &amp;(right_tail-&gt;next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail_holder = &amp;(left_tail-&gt;next);</span><br><span class="line">            &#125;   </span><br><span class="line">NEXT_LOOP:</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head = sorted_list;</span><br><span class="line">                sorted_list = <span class="literal">NULL</span>;</span><br><span class="line">                tail_holder = &amp;sorted_list;</span><br><span class="line">                step *= <span class="number">2</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cutList</span><span class="params">(ListNode* head, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">            ListNode** p_left_head, ListNode** p_left_tail, ListNode** p_right_head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(head != NULL);</span></span><br><span class="line"></span><br><span class="line">        *p_left_head = head;</span><br><span class="line">        *p_left_tail = head;</span><br><span class="line">        *p_right_head = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; head != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line">            *p_left_tail = head;</span><br><span class="line">            *p_right_head = head-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(left != NULL);</span></span><br><span class="line">        <span class="comment">//assert(right != NULL);</span></span><br><span class="line"></span><br><span class="line">        ListNode* merged_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** next_holder = &amp;merged_list;</span><br><span class="line">        ListNode* selected_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                selected_node = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected_node = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            selected_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *next_holder = selected_node;</span><br><span class="line">            next_holder = &amp;(selected_node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        *next_holder = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> merged_list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/11/16/leetcode-sort-list/" data-id="cjdic4k6f000goxs6pvayhnq3" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/11/16/leetcode-sort-list/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/list/">list</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/merge-sort/">merge-sort</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sort/">sort</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zh/">zh</a></li></ul>

    </footer>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/interview/">interview</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ac-search/">ac-search</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/avl-tree/">avl-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clrs/">clrs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-analysis/">code-analysis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/codis/">codis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/">data-structure</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/en/">en</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gorun/">gorun</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libchan/">libchan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list/">list</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/merge-sort/">merge-sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/morris-travesal/">morris-travesal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/">proxy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort/">sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string-match/">string-match</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threaded-binary-tree/">threaded-binary-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threading/">threading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie/">trie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uWSGI/">uWSGI</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zh/">zh</a><span class="tag-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django/" style="font-size: 12px;">Django</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/ac-search/" style="font-size: 10px;">ac-search</a> <a href="/tags/algorithm/" style="font-size: 14px;">algorithm</a> <a href="/tags/avl-tree/" style="font-size: 10px;">avl-tree</a> <a href="/tags/b-tree/" style="font-size: 10px;">b-tree</a> <a href="/tags/clrs/" style="font-size: 10px;">clrs</a> <a href="/tags/code-analysis/" style="font-size: 16px;">code-analysis</a> <a href="/tags/codis/" style="font-size: 10px;">codis</a> <a href="/tags/cpp/" style="font-size: 18px;">cpp</a> <a href="/tags/data-structure/" style="font-size: 14px;">data-structure</a> <a href="/tags/debug/" style="font-size: 10px;">debug</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/en/" style="font-size: 10px;">en</a> <a href="/tags/golang/" style="font-size: 14px;">golang</a> <a href="/tags/gorun/" style="font-size: 10px;">gorun</a> <a href="/tags/leetcode/" style="font-size: 14px;">leetcode</a> <a href="/tags/libchan/" style="font-size: 10px;">libchan</a> <a href="/tags/list/" style="font-size: 10px;">list</a> <a href="/tags/merge-sort/" style="font-size: 10px;">merge-sort</a> <a href="/tags/morris-travesal/" style="font-size: 10px;">morris-travesal</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/stl/" style="font-size: 10px;">stl</a> <a href="/tags/string-match/" style="font-size: 10px;">string-match</a> <a href="/tags/thread/" style="font-size: 10px;">thread</a> <a href="/tags/threaded-binary-tree/" style="font-size: 10px;">threaded-binary-tree</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/tree/" style="font-size: 14px;">tree</a> <a href="/tags/trie/" style="font-size: 10px;">trie</a> <a href="/tags/uWSGI/" style="font-size: 12px;">uWSGI</a> <a href="/tags/zh/" style="font-size: 20px;">zh</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/07/request-processing-in-django/">request processing in Django</a>
          </li>
        
          <li>
            <a href="/2018/02/07/difference-between-manage-py-runserver-and-uswgi/">difference between &#39;manage.py runserver&#39; and uswgi</a>
          </li>
        
          <li>
            <a href="/2018/02/02/Solve-the-problem-of-uwsgi-uwsgi-response-write-body-do-TIMEOUT-error/">Solve  &#39;uwsgi_response_write_body_do() TIMEOUT !!!&#39; error</a>
          </li>
        
          <li>
            <a href="/2015/08/14/codis-network-archi/">Codis请求转发流程分析</a>
          </li>
        
          <li>
            <a href="/2015/04/27/b-tree-implement/">B-Tree实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 kmiku7<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/kmiku7/landscape-k" target="_blank">landscape-k</a>.
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'kmiku7';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>