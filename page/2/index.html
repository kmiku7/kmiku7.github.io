<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kmiku7&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="kmiku7&#39;s blog">
<meta property="og:url" content="http://kmiku7.github.io/page/2/index.html">
<meta property="og:site_name" content="kmiku7&#39;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kmiku7&#39;s blog">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <!--link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"-->
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-27155459-3', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kmiku7&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">JUST DO IT.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kmiku7.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-the-obscure-in-python-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/06/the-obscure-in-python-thread/" class="article-date">
  <time datetime="2015-01-05T16:10:41.000Z" itemprop="datePublished">Jan 6 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/06/the-obscure-in-python-thread/">Python线程的隐晦之处</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记几点python多线程使用里需要注意的地方。</p>
<h3 id="thread-stack-size-size"><a href="#thread-stack-size-size" class="headerlink" title="thread.stack_size([size])"></a>thread.stack_size([size])</h3><p>这是module thread提供的接口，该函数每次调用时都会设置stack size，不加参数就设置stack size为0，也就是使用系统默认值，返回值是之前stack size的“旧值”。不要以为不加参数仅仅是返回stack size。 </p>
<h3 id="thread-local-threading-local-threading-local"><a href="#thread-local-threading-local-threading-local" class="headerlink" title="thread._local, _threading_local, threading.local"></a>thread._local, _threading_local, threading.local</h3><p>thread._local和_threading_local是原始实现， threading提供的只是个alias。mannual page: <a href="https://docs.python.org/2/library/threading.html#threading.local" target="_blank" rel="noopener">link</a>.</p>
<p>_local()每次都会产生一个全新的localobject，实现方式是新建一个localobject，内部封装一个dict，然后对localobject的属性查找都在封装的dict里进行，同时dict也以threadid为key存储在PyThreadState/threading.Thread的dict属性里。没啥用。<br>使用过程中需要由用户持有对localobject的引用，一旦释放localobject也就被析构了，内部存储的数据也会被析构，也就是不能像以下代码里这样用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_a</span><span class="params">()</span>:</span></span><br><span class="line">    tss =thread._local()</span><br><span class="line">    tss.var = tss.var + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_b</span><span class="params">()</span>:</span></span><br><span class="line">    tss = thread._local()</span><br><span class="line">    <span class="keyword">print</span> tss.var</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_proc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        func_a()</span><br><span class="line">        func_b()</span><br></pre></td></tr></table></figure></p>
<p>也就是他无法提供一个线程级的__builtins__ namespace空间。thread._local支持的功能用户可以用更加清晰的方式自己实现。</p>
<h3 id="基于linux实现的thread-module是detach的。"><a href="#基于linux实现的thread-module是detach的。" class="headerlink" title="基于linux实现的thread module是detach的。"></a>基于linux实现的thread module是detach的。</h3><p>其他系统有没有detach这个概念不清楚了。</p>
<h3 id="threading的线程安全性。"><a href="#threading的线程安全性。" class="headerlink" title="threading的线程安全性。"></a>threading的线程安全性。</h3><p>我竟然在说线程库的线程安全性（囧<br>每个threading.Thread()是有个thread-name的，如果初始化参数没有提供会使用如下函数进行生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: threading.py</span></span><br><span class="line">_counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_newname</span><span class="params">(template=<span class="string">"Thread-%d"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _counter</span><br><span class="line">    _counter = _counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> template % _counter</span><br></pre></td></tr></table></figure></p>
<p>threading是python实现的，这段代码也不是线程安全的，生成的thread-name有可能重复。所以还是自己设置thread name吧。<br>可以执行这个脚本测下，输出的thread name是有重复的，我的测试版本是cpython 2.7.5。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.setcheckinterval(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.level = level</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> self.getName()</span><br><span class="line">        <span class="keyword">if</span> self.level &gt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        thread_a = MyThread(self.level+<span class="number">1</span>)</span><br><span class="line">        thread_b = MyThread(self.level+<span class="number">1</span>)</span><br><span class="line">        thread_a.start()</span><br><span class="line">        thread_b.start()</span><br><span class="line"></span><br><span class="line">thread = MyThread(<span class="number">1</span>)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>###importing in threaded code<br>from mannual, <a href="https://docs.python.org/2/library/threading.html#importing-in-threaded-code" target="_blank" rel="noopener">link</a>.</p>
<blockquote>
<p>Firstly, other than in the main module, an import should not have the side effect of spawning a new thread and then waiting for that thread in any way. Failing to abide by this restriction can lead to a deadlock if the spawned thread directly or indirectly attempts to import a module.  </p>
</blockquote>
<p>这条说的是import的时候，要导入的module如果另起一个线程并等待该线程做某些事情，同时该线程里又要执行import操作，这样会导致死锁，main thread也不行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: import.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyImport_ImportModuleLevel(<span class="keyword">char</span> *name, PyObject *globals, PyObject *locals,</span><br><span class="line">             PyObject *fromlist, <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result;</span><br><span class="line">    lock_import();</span><br><span class="line">    result = import_module_level(name, globals, locals, fromlist, level);</span><br><span class="line">    <span class="keyword">if</span> (unlock_import() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_XDECREF(result);</span><br><span class="line">        PyErr_SetString(PyExc_RuntimeError,</span><br><span class="line">                <span class="string">"not holding the import lock"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是cpython的import功能实现代码，虚拟机经过一系列调用到这个函数真正开始import操作。其中的lock_import() &amp; unlock_import()实现了reentrant lock的功能。原因很清楚，虚拟机是字节码级别的中断，该函数是import_name的实现，可以认为是原子的，函数里加的锁不会随着GIL的释放而释放。<br>死锁模拟代码：<a href="https://github.com/kmiku7/python-2.5-annotated/tree/master/code-reading/thread_import" target="_blank" rel="noopener">link</a></p>
<blockquote>
<p>Secondly, all import attempts must be completed before the interpreter starts shutting itself down. This can be most easily achieved by only performing imports from non-daemon threads created through the threading module. Daemon threads and threads created directly with the thread module will require some other form of synchronization to ensure they do not attempt imports after system shutdown has commenced. Failure to abide by this restriction will lead to intermittent exceptions and crashes during interpreter shutdown (as the late imports attempt to access machinery which is no longer in a valid state).  </p>
</blockquote>
<p>这个说的比较清楚了。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2015/01/06/the-obscure-in-python-thread/" data-id="cjd5i7bdj000ecps6oc0zxzsl" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2015/01/06/the-obscure-in-python-thread/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threading/">threading</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-libchan-code-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/21/libchan-code-analysis/" class="article-date">
  <time datetime="2014-11-21T01:41:58.000Z" itemprop="datePublished">Nov 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/21/libchan-code-analysis/">libchan实现分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>libchan是docker衍生出来的子模块，用来在goroutine间、进程间、机器间提供相同的类似go channel的通信方式，<strong>每个channal是单工的</strong>，方便程序从多goroutine到多进程再到多机的扩展。使用上跟linux pipe类似。</p>
<p>项目地址： <a href="https://github.com/docker/libchan" target="_blank" rel="noopener">https://github.com/docker/libchan</a><br>代码版本：commit 1e141b35ee</p>
<p>这是项目里提到的功能：  </p>
<ol>
<li>Simple message passing  </li>
<li>Synchronization for concurrent programming  </li>
<li>Nesting: channels can send channels<br>1/3是可以理解的，2有一点疑问，可以参考项目issue里的讨论。</li>
</ol>
<p>使用方法参考项目里的demo： <a href="https://github.com/docker/libchan/tree/master/examples/rexec" target="_blank" rel="noopener">https://github.com/docker/libchan/tree/master/examples/rexec</a></p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>项目里目前提供了基于tcp/spdy和inmem两种实现，每种实现只需实现以下接口即可：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">interface</span> &#123;</span><br><span class="line">    NewSendChannel() (Sender, error)</span><br><span class="line">    WaitReceiveChannel() (Receiver, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Sender <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(message <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Receiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Receive(message <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inmem没有提供Transport，是通过Pipe()函数成生的sender &amp; receiver，因此spdy/inmen的实现在channel初始化的时候稍有不同。</p>
<h3 id="可打包传输的数据类型"><a href="#可打包传输的数据类型" class="headerlink" title="可打包传输的数据类型"></a>可打包传输的数据类型</h3><p>数据传输使用<a href="https://github.com/dmcgowan/go" target="_blank" rel="noopener">github.com/dmcgowan/go/codec</a>进行编码，打包格式用的msgpack。<br>codec默认支持以下数据类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: https://github.com/dmcgowan/go/blob/master/codec/encode.go</span></span><br><span class="line"><span class="comment">// encDriver abstracts the actual codec (binc vs msgpack, etc)</span></span><br><span class="line"><span class="keyword">type</span> encDriver <span class="keyword">interface</span> &#123;</span><br><span class="line">    isBuiltinType(rt <span class="keyword">uintptr</span>) <span class="keyword">bool</span></span><br><span class="line">    encodeBuiltin(rt <span class="keyword">uintptr</span>, v <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    encodeNil()</span><br><span class="line">    encodeInt(i <span class="keyword">int64</span>)</span><br><span class="line">    encodeUint(i <span class="keyword">uint64</span>)</span><br><span class="line">    encodeBool(b <span class="keyword">bool</span>)</span><br><span class="line">    encodeFloat32(f <span class="keyword">float32</span>)</span><br><span class="line">    encodeFloat64(f <span class="keyword">float64</span>)</span><br><span class="line">    encodeExtPreamble(xtag <span class="keyword">byte</span>, length <span class="keyword">int</span>)</span><br><span class="line">    encodeArrayPreamble(length <span class="keyword">int</span>)</span><br><span class="line">    encodeMapPreamble(length <span class="keyword">int</span>)</span><br><span class="line">    encodeString(c charEncoding, v <span class="keyword">string</span>)</span><br><span class="line">    encodeSymbol(v <span class="keyword">string</span>)</span><br><span class="line">    encodeStringBytes(c charEncoding, v []<span class="keyword">byte</span>)</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="comment">//encBignum(f *big.Int)</span></span><br><span class="line">    <span class="comment">//encStringRunes(c charEncoding, v []rune)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>codec支持扩展，可以注册其他数据类型的编解码句柄。libchan扩展支持Sender/Receiver/io.ReadWriteCloser/io.ReadCloser/io.WriteCloser的打包传输。<br>TCPConn &amp; UDPConn属于io.ReadWriteCloser类型，spdy实现只能传输建立在sender&amp;receiver所在主机之间的连接。</p>
<p>io对象传输的实现流程是：</p>
<ul>
<li>sender端需要打包发送io句柄A  </li>
<li>在sender&amp;receiver之间建立通信管道P(P-Sender, P-Receiver)，inmem、spdy分别使用net.Pipe和spdy.stream建立。  </li>
<li>sender起goroutine在A &amp; P-Sender间进行数据拷贝，发送管道P的ID，receiver端对P-receiver进行读写。 </li>
</ul>
<p>操作完成后的情况如下图：</p>
<p><img src="/img/libchan-send-io.png" alt="" title="libchan-send-io.png"></p>
<p>###代码分析</p>
<p>####inmem<br>每一对sender&amp;receiver都有与之关联的一个session数据结构，用来管理通过该chan传输的sender、receiver、io对象等。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> streamSession <span class="keyword">struct</span> &#123;</span><br><span class="line">    pipeLock    sync.Mutex</span><br><span class="line">    pipeCount   <span class="keyword">uint64</span></span><br><span class="line">    pipeReaders <span class="keyword">map</span>[<span class="keyword">uint64</span>]*io.PipeReader</span><br><span class="line">    pipeWriters <span class="keyword">map</span>[<span class="keyword">uint64</span>]*io.PipeWriter</span><br><span class="line"></span><br><span class="line">    handler codec.Handle</span><br><span class="line"></span><br><span class="line">    referenceLock sync.Mutex</span><br><span class="line">    referenceID   <span class="keyword">uint64</span></span><br><span class="line">    byteStreams   <span class="keyword">map</span>[<span class="keyword">uint64</span>]*byteStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handler是一个codec编解码句柄。<br>io对象的传输是通过net.Pipe()创建的管道和sender端的proxy实现，IO通道存储在byteStreams字段里，net.Pipe()返回两个句柄，对应两个byteStream对象，分别存储在map[ref_ID] map[ref_ID+1]里，本地使用map[ref_ID]进行读写，传输ref_ID+1给对端，对端使用map[ref_ID+1]的对象读写。<br>io.ReadClose &amp; io.WriteClose &amp; io.ReadWriteCloser实现方式相同，只是在sender端起的proxy routine不同。byteStream是可读写的，根据存储byteStream对象的字段类型的不同会表现出只读、只写、读写的不同特征。</p>
<p>Sender &amp; Receiver通过io.Pipe()传输数据，返回的通道是单工的，读写两端分别存储在pipeReaders &amp; pipeWriters字段里。S &amp; R传输处理流程类似，比如senderA.send(otherB)，如果senderB属于senderA的session，则直接传输对应的map-key，如果不是则新建一个io.Pipe，通过goroutine io.copy实现转发。</p>
<p>接下来分析下io.ReadWriteCloser、Sender对象编码传输、解码使用的流程。</p>
<p>#####临时对象构造<br>首先对要传输的对象构造出来一个临时的拷贝，其中的io.ReadWriteCloser/Sender转换成内部对应的bytesStream对象和同session的Sender，如有需要，转发的proxy都已启动。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copyValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> val := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> *pipeSender:</span><br><span class="line">        <span class="keyword">if</span> val.session != w.session &#123;</span><br><span class="line">            <span class="keyword">return</span> w.copySender(val)</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> io.ReadWriteCloser:</span><br><span class="line">        <span class="keyword">return</span> w.copyByteStream(val)</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copyByteStream行为是在该session内新建一个net.Pipe，然后启动转发的proxy-routine。newByteStream()创建一对byteStream对象代表net.Pipe的两端，存储在byteStreams字段里，id分别为referenceID和referenceID+1，referenceID+1给对端使用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copyByteStream</span><span class="params">(stream io.ReadWriteCloser)</span> <span class="params">(io.ReadWriteCloser, error)</span></span> &#123;</span><br><span class="line">    streamCopy, err := w.session.newByteStream()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(streamCopy, stream)</span><br><span class="line">        streamCopy.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(stream, streamCopy)</span><br><span class="line">        stream.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> streamCopy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">newByteStream</span><span class="params">()</span> <span class="params">(io.ReadWriteCloser, error)</span></span> &#123;</span><br><span class="line">    c1, c2 := net.Pipe()</span><br><span class="line">    bs := &amp;byteStream&#123;</span><br><span class="line">        Conn:        c1,</span><br><span class="line">        referenceID: s.referenceID,</span><br><span class="line">        session:     s,</span><br><span class="line">    &#125;</span><br><span class="line">    s.referenceLock.Lock()</span><br><span class="line">    s.byteStreams[s.referenceID] = bs</span><br><span class="line">    s.byteStreams[s.referenceID+<span class="number">1</span>] = &amp;byteStream&#123;</span><br><span class="line">        Conn:        c2,</span><br><span class="line">        referenceID: s.referenceID + <span class="number">1</span>,</span><br><span class="line">        session:     s,</span><br><span class="line">    &#125;</span><br><span class="line">    s.referenceID = s.referenceID + <span class="number">2</span></span><br><span class="line">    s.referenceLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copySender()行为类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *pipeSender)</span> <span class="title">copySender</span><span class="params">(val Sender)</span> <span class="params">(Sender, error)</span></span> &#123;</span><br><span class="line">    recv, send, err := w.CreateNestedReceiver()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Copy(val, recv)</span><br><span class="line">        val.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> send, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####序列化<br>byteStream和Sender使用注册的codec扩展句柄编码，byteStream编码函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">encodeStream</span><span class="params">(v reflect.Value)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    bs := v.Interface().(byteStream)</span><br><span class="line">    <span class="keyword">if</span> bs.referenceID == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"bad type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    written := binary.PutUvarint(buf[:], <span class="keyword">uint64</span>(bs.referenceID)^<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf[:written], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStream每次都创建一对，并且referenceID从2顺序使用，因此本端对象的referenceID总是偶数，对端使用referenceID+1存储的byteStream，uint64(bs.referenceID)^0x01等价于bs.referenceID+1，这个地方太绕了。<br>encodeSender()编码Sender对象，行为类似。</p>
<p>#####反序列化<br>对于一个整数，反序列化后的类型取决于存储他的对象类型，所以收发两端的数据结构不对应就会出错。byteStream反序列化逻辑如下，Sender处理逻辑类似。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *streamSession)</span> <span class="title">decodeStream</span><span class="params">(v reflect.Value, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    referenceID, readN := binary.Uvarint(b)</span><br><span class="line">    <span class="keyword">if</span> readN == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"bad reference id"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs, ok := s.byteStreams[referenceID]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"byte stream does not exist"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bs != <span class="literal">nil</span> &#123;</span><br><span class="line">        v.Set(reflect.ValueOf(*bs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStream结构体嵌入了net.Conn，因此是一个io.ReadWriteClose对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byteStream <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    referenceID <span class="keyword">uint64</span></span><br><span class="line">    session     *streamSession</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####spdy<br>这是一个基于tcp+spdy作为传输层的实现，每一对sender&amp;receiver或io对象都对应spdy的一个stream。spdy实现了Transport，也使用该数据结构管理在一个chan间传输的sub-chan、io对象的信息。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    *spdystream.Connection</span><br><span class="line">    handler codec.Handle</span><br><span class="line"></span><br><span class="line">    receiverChan <span class="keyword">chan</span> *channel</span><br><span class="line">    channelC     *sync.Cond</span><br><span class="line">    channels     <span class="keyword">map</span>[<span class="keyword">uint64</span>]*channel</span><br><span class="line"></span><br><span class="line">    referenceLock    sync.Mutex</span><br><span class="line">    referenceCounter <span class="keyword">uint64</span></span><br><span class="line">    byteStreamC      *sync.Cond</span><br><span class="line">    byteStreams      <span class="keyword">map</span>[<span class="keyword">uint64</span>]*byteStream</span><br><span class="line"></span><br><span class="line">    netConnC *sync.Cond</span><br><span class="line">    netConns <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn</span><br><span class="line">    networks <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> channel <span class="keyword">struct</span> &#123;</span><br><span class="line">    referenceID <span class="keyword">uint64</span></span><br><span class="line">    parentID    <span class="keyword">uint64</span></span><br><span class="line">    stream      *spdystream.Stream</span><br><span class="line">    session     *Transport</span><br><span class="line">    direction   direction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>byteStreams存储io对象转发的通道，使用TCPConn传输，因此是双工的。怎么使用依赖于持有他的对象。<br>channels存储两机间的chan通道。channel封装了一个byteStream对象和direction字段，因此只能单向使用。</p>
<p>因为Sender&amp;Receiver和io对象都通过spdy的stream实现，所以stream建立的时候就需要进行区分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">newStreamHandler</span><span class="params">(stream *spdystream.Stream)</span></span> &#123;</span><br><span class="line">    referenceIDString := stream.Headers().Get(<span class="string">"libchan-ref"</span>)</span><br><span class="line">    parentIDString := stream.Headers().Get(<span class="string">"libchan-parent-ref"</span>)</span><br><span class="line"></span><br><span class="line">    returnHeaders := http.Header&#123;&#125;</span><br><span class="line">    finish := <span class="literal">false</span></span><br><span class="line">    referenceID, parseErr := strconv.ParseUint(referenceIDString, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> parseErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"400"</span>)</span><br><span class="line">        finish = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parentIDString区分了channel和stream</span></span><br><span class="line">        <span class="keyword">if</span> parentIDString == <span class="string">""</span> &#123;</span><br><span class="line">            byteStream := &amp;byteStream&#123;</span><br><span class="line">                referenceID: referenceID,</span><br><span class="line">                stream:      stream,</span><br><span class="line">                session:     s,</span><br><span class="line">            &#125;</span><br><span class="line">            s.byteStreamC.L.Lock()</span><br><span class="line">            s.byteStreams[referenceID] = byteStream</span><br><span class="line">            s.byteStreamC.Broadcast()</span><br><span class="line">            s.byteStreamC.L.Unlock()</span><br><span class="line"></span><br><span class="line">            returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"200"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentID, parseErr := strconv.ParseUint(parentIDString, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">            <span class="keyword">if</span> parseErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"400"</span>)</span><br><span class="line">                finish = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c := &amp;channel&#123;</span><br><span class="line">                    referenceID: referenceID,</span><br><span class="line">                    parentID:    parentID,</span><br><span class="line">                    stream:      stream,</span><br><span class="line">                    session:     s,</span><br><span class="line">                &#125;</span><br><span class="line">                s.channelC.L.Lock()</span><br><span class="line">                s.channels[referenceID] = c</span><br><span class="line">                s.channelC.Broadcast()</span><br><span class="line">                s.channelC.L.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// subchannel是没有方向概念的</span></span><br><span class="line">                <span class="keyword">if</span> parentID == <span class="number">0</span> &#123;</span><br><span class="line">                    c.direction = inbound</span><br><span class="line">                    s.receiverChan &lt;- c</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                returnHeaders.Set(<span class="string">"status"</span>, <span class="string">"200"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream.SendReply(returnHeaders, finish)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果parentIDString为空，则是一个byteStream，该stream只读、只写、读写是由持有他的对象决定的。parentIDString非空且不等于0，则是在两机间新建一个管道，创建总是由sender端发起；如果不等于，则是一个subchannel，该chan用来发送还是接收是由持有他的对象决定的。</p>
<p>spdy实现在函数initializeHandler()注册的扩展类型编解码句柄：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">initializeHandler</span><span class="params">()</span> *<span class="title">codec</span>.<span class="title">MsgpackHandle</span></span> &#123;</span><br><span class="line">    mh := &amp;codec.MsgpackHandle&#123;WriteExt: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register networks</span></span><br><span class="line">    s.networks[<span class="string">"tcp"</span>] = <span class="number">0x04</span></span><br><span class="line">    s.netConns[<span class="number">0x04</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn)</span><br><span class="line">    err = mh.AddExt(reflect.TypeOf(net.TCPConn&#123;&#125;), <span class="number">0x04</span>, s.encodeNetConn, s.decodeNetConn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.networks[<span class="string">"udp"</span>] = <span class="number">0x05</span></span><br><span class="line">    s.netConns[<span class="number">0x05</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn)</span><br><span class="line">    err = mh.AddExt(reflect.TypeOf(net.UDPConn&#123;&#125;), <span class="number">0x05</span>, s.encodeNetConn, s.decodeNetConn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO add unix network as 0x06</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比inmem增加了TCPConn和UDPConn的额外处理。因此这也限制了spdy只能传输在两机间建立的连接，且接收端已经将该conn注册到这个session内。<br>这是代码中的注释：</p>
<blockquote>
<p>// RegisterConn registers a network connection to be used<br>// by inbound messages referring to the connection<br>// with the registered connection’s local and remote address.<br>// Note: a connection does not need to be registered before<br>// being sent in a message, but does need to be registered<br>// to by the receiver of a message. If registration should be<br>// automatic, register a listener instead.  </p>
</blockquote>
<p>注册的连接保存在netConns字段内，使用二维map存储：map[network-type][localaddr&lt;&gt;remoteaddr]。传输时编码的是一个三元组(network-type, local-addr, remote-addr) 。实现函数是<em>encodeNetConn(), decodeNetConn()</em>，注意解码时的字段顺序。</p>
<p>网络连接的传输可以参考这个测试用例：<a href="https://github.com/docker/libchan/blob/master/spdy/conn_test.go" target="_blank" rel="noopener">https://github.com/docker/libchan/blob/master/spdy/conn_test.go</a></p>
<p>###summary<br>总体来说channel通信方式使用很直观方便，屏蔽了底层的通信建立细节。但是实现方式不容易理解，看了spdy代码也不放心，出了问题debug有困难，比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Transport)</span> <span class="title">getByteStream</span><span class="params">(referenceID <span class="keyword">uint64</span>)</span> *<span class="title">byteStream</span></span> &#123;</span><br><span class="line">    s.byteStreamC.L.Lock()</span><br><span class="line">    bs, ok := s.byteStreams[referenceID]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        s.byteStreamC.Wait()</span><br><span class="line">        bs, ok = s.byteStreams[referenceID]</span><br><span class="line">    &#125;</span><br><span class="line">    s.byteStreamC.L.Unlock()</span><br><span class="line">    <span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>if是不是应该换成while判断。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/11/21/libchan-code-analysis/" data-id="cjd5i7bdo000jcps6cemscgbi" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/11/21/libchan-code-analysis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code-analysis/">code-analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libchan/">libchan</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode-sort-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/16/leetcode-sort-list/" class="article-date">
  <time datetime="2014-11-16T06:42:25.000Z" itemprop="datePublished">Nov 16 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/interview/">interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/16/leetcode-sort-list/">LeetCode - Sort List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Sort List<br>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>
<p>排序一个单向链表，要求时间复杂度O(nlgn)，空间复杂度O(1)。使用merge sort解该问题，网上的答案用的都是递归的解法，也就是top-down的实现，空间复杂度应该为O(lgn)，并不是常数，使用bottom-up的实现可以达到O(1)的空间复杂度。</p>
<p><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">wikipedia</a>只给出了数组的top-down &amp; bottom-up实现和list的top-down实现。<br>这里的快慢指针技巧非常有用：<a href="http://www.cnblogs.com/x1957/p/3492219.html" target="_blank" rel="noopener">link1</a> <a href="http://blog.csdn.net/jiadebin890724/article/details/21334059" target="_blank" rel="noopener">link2</a>。<br>链表的实现有带头节点和不带头节点两种形式，不带头节点的实现需要判断head==NULL的情况，带头节点则会浪费一个节点的空间。对于不带头节点的链表，各个操作可以用二级指针实现，把代码书写上的复杂度转移到coder的脑袋里。</p>
<h3 id="Talk-is-cheap-show-you-the-code"><a href="#Talk-is-cheap-show-you-the-code" class="headerlink" title="Talk is cheap, show you the code:"></a>Talk is cheap, show you the code:</h3><p>两个bottom-up的实现，第一个空间复杂度O(n)，最多需要存储n/2个链表头指针。</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1."></a>Code 1.</h4><p>这里的queue使用list会超时。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="built_in">deque</span>&lt;ListNode*&gt; <span class="built_in">queue</span>;</span><br><span class="line">        ListNode* iter = head;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.push_back(iter);</span><br><span class="line">            next = iter-&gt;next;</span><br><span class="line">            iter-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            iter = next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            iter = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop_front();</span><br><span class="line">            next = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop_front();</span><br><span class="line">            <span class="built_in">queue</span>.push_back(mergeList(iter, next));</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.front();   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* merged_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** next_holder = &amp;merged_list;</span><br><span class="line">        ListNode* selected_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                selected_node = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected_node = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;   </span><br><span class="line">            selected_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *next_holder = selected_node;</span><br><span class="line">            next_holder = &amp;(selected_node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        *next_holder = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> merged_list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code 2."></a>Code 2.</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(head != NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = length(head);</span><br><span class="line">        ListNode* sorted_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** tail_holder = &amp;sorted_list;</span><br><span class="line">        <span class="keyword">while</span> (step &lt; len) &#123;</span><br><span class="line">            ListNode* left_head = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* left_tail = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* right_head = <span class="literal">NULL</span>;</span><br><span class="line">            ListNode* right_tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            cutList(head, step, &amp;left_head, &amp;left_tail, &amp;head);</span><br><span class="line">            left_tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *tail_holder = left_head;</span><br><span class="line">                <span class="keyword">goto</span> NEXT_LOOP;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            cutList(head, step, &amp;right_head, &amp;right_tail, &amp;head);</span><br><span class="line">            right_tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *tail_holder = mergeList(left_head, right_head);</span><br><span class="line">            <span class="comment">//assert( (left_tail-&gt;next == NULL &amp;&amp; right_tail-&gt;next != NULL)</span></span><br><span class="line">            <span class="comment">//        || (left_tail-&gt;next != NULL &amp;&amp; right_tail-&gt;next == NULL));</span></span><br><span class="line">            <span class="keyword">if</span> (right_tail-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tail_holder = &amp;(right_tail-&gt;next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail_holder = &amp;(left_tail-&gt;next);</span><br><span class="line">            &#125;   </span><br><span class="line">NEXT_LOOP:</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head = sorted_list;</span><br><span class="line">                sorted_list = <span class="literal">NULL</span>;</span><br><span class="line">                tail_holder = &amp;sorted_list;</span><br><span class="line">                step *= <span class="number">2</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cutList</span><span class="params">(ListNode* head, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">            ListNode** p_left_head, ListNode** p_left_tail, ListNode** p_right_head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(head != NULL);</span></span><br><span class="line"></span><br><span class="line">        *p_left_head = head;</span><br><span class="line">        *p_left_tail = head;</span><br><span class="line">        *p_right_head = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; head != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line">            *p_left_tail = head;</span><br><span class="line">            *p_right_head = head-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert(left != NULL);</span></span><br><span class="line">        <span class="comment">//assert(right != NULL);</span></span><br><span class="line"></span><br><span class="line">        ListNode* merged_list = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode** next_holder = &amp;merged_list;</span><br><span class="line">        ListNode* selected_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                selected_node = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected_node = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            selected_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            *next_holder = selected_node;</span><br><span class="line">            next_holder = &amp;(selected_node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        *next_holder = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> merged_list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/11/16/leetcode-sort-list/" data-id="cjd5i7bdl000fcps6w5caslpk" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/11/16/leetcode-sort-list/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/list/">list</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/merge-sort/">merge-sort</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sort/">sort</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpp-vector-deque-stack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/15/cpp-vector-deque-stack/" class="article-date">
  <time datetime="2014-11-15T08:15:31.000Z" itemprop="datePublished">Nov 15 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/15/cpp-vector-deque-stack/">c++ vector和deque的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用c++解Min Stack的时候被Memory Limit Exceeded搞的很头痛，自己写过链表、空间可增长的数组，用了stl的vector、deque，最后是deque的实现可以通过，搜了下也有用stack过的。<br>在这里记录下deque&amp;stack跟其他实现的区别。</p>
<p>这是cplusplus <a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">deque</a>页面的讲的vector和deque实现的区别：  </p>
<blockquote>
<p>Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways: While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a deque can be scattered in different chunks of storage, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators). Therefore, deques are a little more complex internally than vectors, but this allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocations become more expensive.</p>
</blockquote>
<p>vector用的是一个数组，剩余空间不够时申请一个size-doubled的新数组，然后把原数据拷贝过来。而deque因为是双向的，如果还是像vector这种实现方式空间浪费会比较多，所以使用了多个chunk存储数据，然后用一个T*进行索引，当空间不够时新分配一个chunk，chunk大小也是固定的。  </p>
<p>leetcode一组测试数据共插入7w个整数，需要空间28w bytes，大于等于该值的最小的2的幂次方是2^18=524288，使用vector消耗的差不多就是这么大，额外消耗238kb，即使用vector::resize()预分配空间也依赖于内存分配器的行为。<br>使用deque的话，数据存储空间大约是(28w/512+1)*512 byte，最多浪费512字节；索引的话，28w/512=546， 索引占用1024*sizeof(int*)，额外消耗4.5kb(64位8.5kb)。deque里每个chunk大小的计算公式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item_size = <span class="keyword">sizeof</span>(T)</span><br><span class="line">(item_size &lt; <span class="number">512</span> ? (<span class="number">512</span> / item_size) : <span class="number">1</span>) * item_size</span><br></pre></td></tr></table></figure></p>
<p>stl里的stack是一种container adaptor，底层使用deque实现，因此内存消耗与deque相同。</p>
<p>这篇文章<a href="http://daoluan.net/blog/stl-deque/" target="_blank" rel="noopener">link</a>介绍了deque的实现，图画的很好。<br>stl的实现原理可以参考侯捷的《STL源码剖析》和stl代码。</p>
<p>min stack实现代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> (min.size() &lt;= <span class="number">0</span> || x &lt;= min.back()) &#123;</span><br><span class="line">            min.push_back(x);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stack_last = <span class="built_in">stack</span>.back();</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        <span class="keyword">int</span> min_last = min.back();</span><br><span class="line">        <span class="keyword">if</span> (stack_last == min_last) &#123;</span><br><span class="line">            min.pop_back();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.back();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/11/15/cpp-vector-deque-stack/" data-id="cjd5i7bdg0009cps62q8cqkxj" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/11/15/cpp-vector-deque-stack/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code-analysis/">code-analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-gorun-code-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/25/gorun-code-analysis/" class="article-date">
  <time datetime="2014-10-25T12:01:22.000Z" itemprop="datePublished">Oct 25 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/25/gorun-code-analysis/">gorun实现分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习golang的时候想写点代码还得到特定的目录结构下，build &amp; run，实在是太罗嗦，好在Programming in Go这本书一开始就提到了把golang当作脚本语言使的工具，但是直到这本书快看完了才受够了这个流程决定使用这两个工具（好强的忍耐力。。。</p>
<p>这篇文章是对gorun代码的分析，项目地址是：<a href="https://wiki.ubuntu.com/gorun" target="_blank" rel="noopener">https://wiki.ubuntu.com/gorun</a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">gorun &lt;source-file&gt; [option...]</span><br><span class="line">```  </span><br><span class="line">option是传给source-file的参数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>## 处理流程</span><br><span class="line">脚本实现思路是把输入的源文件拷贝到系统TempDir目录下，然后编译执行。大致流程如下：</span><br><span class="line">* 创建工作目录：  </span><br><span class="line">rundir = TMPDIR/gorun-hostname-euid[-NUM]/GOOS_GOARCH</span><br><span class="line">* 生成可执行文件的文件名：  </span><br><span class="line">runfile = EvalSymlinks(Abs(sourcefile)), Replace("%"-&gt;"%%", filepath.Separator-&gt;"%")</span><br><span class="line">* 基于ModTime检测源文件相对上次编译是否更新</span><br><span class="line">若不需要重新编译，则touch(runfile) &amp; CleanDir(rundir)，请注意touch的原因</span><br><span class="line">* 若需要编译则调用go tool工具编译，这样可以指定产出文件。  </span><br><span class="line">如果源文件首行以#!开头，则会生成一个临时的源文件runfile.pid.go并且编译后删除。原因是代码还是用go编译的，#!不符合go的语法，因此源文件除了首行可以以#!开头外，其他地方都要符合go的语法。  </span><br><span class="line">* 之后使用系统调用exec执行，如果是因为目标文件不存在导致失败则会有重试。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目前代码里有个小问题：</span><br><span class="line">```go</span><br><span class="line">// CleanDir removes binary files under rundir in case they were not</span><br><span class="line">// accessed for more than CleanFileDelay nanoseconds.  A last-cleaned</span><br><span class="line">// marker file is created so that the next verification is only done</span><br><span class="line">// after CleanFileDelay nanoseconds.</span><br><span class="line">func CleanDir(rundir string, now time.Time) error &#123;</span><br><span class="line">    cleanedfile := filepath.Join(rundir, "last-cleaned")</span><br><span class="line">    cleanLine := now.Add(-CleanFileDelay)</span><br><span class="line">    if info, err := os.Stat(cleanedfile); err == nil &amp;&amp; info.ModTime().After(cleanLine) &#123;</span><br><span class="line">        // It's been cleaned recently.</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f, err := os.Create(cleanedfile)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = f.Write([]byte(now.Format(time.RFC3339)))</span><br><span class="line">    f.Close()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Look for expired files.</span><br><span class="line">    d, err := os.Open(rundir)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    infos, err := d.Readdir(-1)</span><br><span class="line">    for _, info := range infos &#123;</span><br><span class="line">        atim := sysStat(info).Atim</span><br><span class="line">        access := time.Unix(int64(atim.Sec), int64(atim.Nsec))</span><br><span class="line">        if access.Before(cleanLine) &#123;</span><br><span class="line">            os.Remove(filepath.Join(rundir, info.Name()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在判断”old compiled files”用的是atime，首先文件系统可以配置不记录atime，这样的话就没法判断bin文件是不是被用过。然后是如果文件已经存在，则Create不会更新atime，这就导致last-cleaned也会被删除，下一次gorun还会调用CleanDir一次。但是都不是大问题，atime本身比较蛋疼需要注意。</p>
<p>还有就是go run可以编译并执行源程序，再用第三方脚本就没必要了。</p>

      
    </div>
    <footer class="article-footer">
      <!--a data-url="http://kmiku7.github.io/2014/10/25/gorun-code-analysis/" data-id="cjd5i7bde0006cps6epxo41kn" class="article-share-link">Share</a-->
      
        <a href="http://kmiku7.github.io/2014/10/25/gorun-code-analysis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code-analysis/">code-analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gorun/">gorun</a></li></ul>

    </footer>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/interview/">interview</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ac-search/">ac-search</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/avl-tree/">avl-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clrs/">clrs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-analysis/">code-analysis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/codis/">codis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/">data-structure</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gorun/">gorun</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libchan/">libchan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list/">list</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/merge-sort/">merge-sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/morris-travesal/">morris-travesal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/">proxy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort/">sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string-match/">string-match</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threaded-binary-tree/">threaded-binary-tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threading/">threading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie/">trie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uWSGI/">uWSGI</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Python/" style="font-size: 12.5px;">Python</a> <a href="/tags/ac-search/" style="font-size: 10px;">ac-search</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/avl-tree/" style="font-size: 10px;">avl-tree</a> <a href="/tags/b-tree/" style="font-size: 10px;">b-tree</a> <a href="/tags/clrs/" style="font-size: 10px;">clrs</a> <a href="/tags/code-analysis/" style="font-size: 17.5px;">code-analysis</a> <a href="/tags/codis/" style="font-size: 10px;">codis</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/data-structure/" style="font-size: 15px;">data-structure</a> <a href="/tags/debug/" style="font-size: 10px;">debug</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/gorun/" style="font-size: 10px;">gorun</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/libchan/" style="font-size: 10px;">libchan</a> <a href="/tags/list/" style="font-size: 10px;">list</a> <a href="/tags/merge-sort/" style="font-size: 10px;">merge-sort</a> <a href="/tags/morris-travesal/" style="font-size: 10px;">morris-travesal</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/stl/" style="font-size: 10px;">stl</a> <a href="/tags/string-match/" style="font-size: 10px;">string-match</a> <a href="/tags/thread/" style="font-size: 10px;">thread</a> <a href="/tags/threaded-binary-tree/" style="font-size: 10px;">threaded-binary-tree</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/tree/" style="font-size: 15px;">tree</a> <a href="/tags/trie/" style="font-size: 10px;">trie</a> <a href="/tags/uWSGI/" style="font-size: 10px;">uWSGI</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/02/Solve-the-problem-of-uwsgi-uwsgi-response-write-body-do-TIMEOUT-error/">Solve the problem of uwsgi &#39;uwsgi_response_write_body_do() TIMEOUT !!!&#39; error</a>
          </li>
        
          <li>
            <a href="/2015/08/14/codis-network-archi/">Codis请求转发流程分析</a>
          </li>
        
          <li>
            <a href="/2015/04/27/b-tree-implement/">B-Tree实现</a>
          </li>
        
          <li>
            <a href="/2015/04/25/basic-aho-corasick-algorithm/">AC-Search实现</a>
          </li>
        
          <li>
            <a href="/2015/04/24/leetcode-combination-sum-ii/">LeetCode - Combination Sum II</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 kmiku7<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/kmiku7/landscape-k" target="_blank">landscape-k</a>.
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'kmiku7';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>